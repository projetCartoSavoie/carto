<?php
/**
 * MotRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 *
 * @author Rémy Cluze <Remy.Cluze@etu.univ-savoie.fr>
 * @author Anthony Di Lisio <Anthony.Di-Lisio@etu.univ-savoie.fr>
 * @author Juliana Leclaire <Juliana.Leclaire@etu.univ-savoie.fr>
 * @author Rémi Mollard <Remi.Mollard@etu.univ-savoie.fr>
 * @author Céline de Roland <Celine.de-Roland@etu.univ-savoie.fr>
 *
 * @version 1.0
 */
namespace Carto\DonneesBundle\Entity\WN;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Query\Expr\Comparison;

/**
 * MotRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class MotRepository extends EntityRepository
{

/**
 * Résultat
 *
 * @var array $resultat : tableau php représentant le graphe autour d'un mot
 */
	private $resultat;

/**
 * Mot
 *
 * @var Carto\DonneesBundle\Entity\WN\Mot : mot demandé
 */
	private $mot;

/**
 * Profondeur. Pour chaque relation, dès qu'on la trouve on incrémente la profondeur pour savoir si on a atteint le maximum
 *
 * @var array of integer : profondeur actuelle pour chaque relation
 */
	private $profondeur;

/**
 * Profondeur maximale demandée par l'utilisateur.
 *
 * @var integer
 */
	private $profondeurMax;

/**
 * Liste des id déjà vues. Permet de savoir quels mots et synsets ont déjà été inscrits dans la liste de noeuds, afin de n'en oublier aucun et de ne pas faire de doublons.
 *
 * @var array
 */
	private $listeId;

	/**
	 * fonction trouve
	 *
	 * Si le mot cherché est dans la base de données, alors la fonction
	 * renvoie le mot correspondant
	 * Sinon on cherche un mot qui ressemble à la recherche dans la bdd
	 * et on renvoie le mot correspondant
	 *
	 * @param string $recherche
	 * @return Carto\DonneesBundle\Entity\WN\Mot
	*/
	public function trouve($recherche)
	{
		$mot = $this -> findOneByMot($recherche);
		if ($mot != NULL)
		{
			return $mot;
		}
		else
		{
			//On cherche tous les mots ayant 3 caractères en commun avec la recherche
			$query = $this -> getEntityManager() -> createQuery(
				'SELECT m
				FROM CartoDonneesBundle:WN\Mot m
				WHERE m.mot LIKE :court'
			);
			$mots = array();
			for ($i = 0; $i < strlen($recherche) - 2; $i++)
			{
				$regex = substr($recherche,$i,3);
				$query->setParameter('court', '%'.$regex.'%');
				$mots = array_merge($mots, $query -> getResult());
			}

			//On remplace le tableau d'objets par un tableau de chaines de caractères
			$strmots = array();
			foreach ($mots as $m)
			{
				$strmots[] = $m -> getMot();
			}

			//Pour chaque mot on calcule son taux de correspondance
			$correspondances = array();
			foreach ($strmots as $m)
			{
				$correspondance[$m] = $this -> calculCorrespondance($m,$recherche);
			}
			$minindex = min($correspondance);
			$correspondance = array_flip($correspondance);

			//On retourne l'objet Mot correspondant au plus bas taux de correspondance
			$mot = $this -> findOneByMot($correspondance[$minindex]);
			return $mot;
		}
	}

	/**
	 * Calcul un taux de différence entre deux mots
	 *
	 * tient compte de la ressemblance sonore et de la
	 * ressemblance en terme de caractères (nombre d'insertions et suppressions
	 * nécessaires pour passer d'une chaine à l'autre)
	 * plus le résultat est petit plus les mots se ressemblent
	 *
	 * @param string $recherche
	 * @param string $m (mot à comparer à la recherche)
	 * @return integer
	*/
	public function calculCorrespondance($m,$recherche)
	{
		$c = levenshtein($m,$recherche);
		if (soundex($m) == soundex($recherche)) { $c -= 10; }
		return $c;
	}

	/**
	 * Fabrique un json au format commun correspondant à la recherche demandée
	 *
	 * Pour les explications voir présentation écrite et orale
	 *
	 * @param string $recherche
	 * @param string $options : liste des relations à prendre en compte
	 * @param integer $profondeur : profondeur de la recherche à effectuer
	 * @return string chaine de caractère au format json commun
	*/
	public function fabriqueGraphe($recherche,$options,$profondeur)
	{
		$this -> profondeurMax = $profondeur;

		//Au départ la profondeur est de 0 pour toutes les relations.
		//On incrémentera la profondeur en construisant les branches du graphe,
		//jusqu'à atteindre la profondeur maximale
		$this -> profondeur = array(
				'hypernymie' => 0,
				'hyponymie' => 0,
				'meronymie' => 0,
				'holonymie' => 0,
				'troponymie' => 0,
				'verbe_hyponymie' => 0,
				'entailments' => 0,
				'verbe_holonymie' => 0,
				'antonymie' => 0,
				'attribut' => 0,
				'cause' => 0,
				'consequence' => 0,
				'similar' => 0,
				'synonymie' => 0
		);

		//Si option est défini à all, on les met toutes
		if ($options == 'all')
		{
			$relations = array(
				'derivation',
				'pertainymie',
				'construction',
				'participe_passe',
				'hypernymie',
				'hyponymie',
				'meronymie',
				'holonymie',
				'troponymie',
				'verbe_hyponymie',
				'entailments',
				'antonymie',
				'attribut',
				'cause',
				'consequence',
				'similar',
				'synonymie',
			);
		}
		//Sinon la liste de relations séparées par des virgules est transformée en tableau
		else { $relations = explode(',',$options); }
		
		//Initialisation du tableau résultat, qui sera ensuite encodé en json
		$this -> resultat = array(
			'noeuds' => array(), 
			'relations' => array_merge($relations,array('groupe_initial')),
			'graphe' => array()
		);
		//On a ajouté la relation groupe_initial, car dans le cas où la synonymie n'est pas cochée, on doit donner un nom à la relation de départ entre le mot recherché et ses synsets.

		//Recherche du mot demandé et ajout dans la liste des noeuds et dans le graphe
		$this -> mot = $this -> trouve($recherche);
		$this -> resultat['noeuds'][] = array(
			'id' => 'M'.$this -> mot -> getId(),
			'nom' => $this -> mot -> getMot(),
			'type' => 'M'
		);
		$this -> resultat['graphe']['M'.$this -> mot -> getId()] = array( 'noeud' => 'M'.$this -> mot -> getId() );
		$this -> listeid = array('M'.$this -> mot -> getId());


		//On cherche les relations entre mots : relations lexicales
		$relations_mots = array(
				'derivation',
				'pertainymie',
				'construction',
				'participe_passe'
		);
		$this -> relationsentremots($this -> mot,array_intersect($relations_mots,$relations));


		//Si on veut d'autres relations, on cherche les synsets du mot et leurs relations
		$relationsentresynsets = array_diff($relations,$relations_mots);
		if (count($relationsentresynsets) != 0)
		{
			//parcourirMot va lancer la recherche des relations du mot
			if (in_array('synonymie',$relations)) { $this -> parcourirMot($this -> mot,$relations,'synonymie'); }
			else { $this -> parcourirMot($this -> mot,$relations,'groupe_initial'); }
		}


		//On enlève les clés du tableau graphe pour correspondre au format commun
		$this -> resultat['graphe'] = array_values($this -> resultat['graphe']);

		//On retourne le tableau obtenu
		return $this -> resultat;

	}

/****************************
  RELATIONS ENTRE MOTS
****************************/

	/**
	 * Pour chaque relation lexicale sélectionnée, on utilise parcourir pour trouver les mots en relation avec le mot de départ
	 *
	 * @param string $motdep : mot de départ
	 * @param array $relations : liste des relations lexicales à prendre en compte
	*/
	private function relationsentremots($motdep,$relations)
	{
		if (in_array('derivation',$relations))
		{
			$derivation = $motdep -> getAllDerive();
			$this -> parcourir($motdep,$derivation,'derivation',$relations);
		}
		if (in_array('pertainymie',$relations))
		{
			$pertainymie = $motdep -> getAllPertainym();
			$this -> parcourir($motdep,$pertainymie,'pertainymie',$relations);
		}
		if (in_array('construction',$relations))
		{
			$construction = $motdep -> getAllBuild();
			$this -> parcourir($motdep,$construction,'construction',$relations);
		}
		if (in_array('participe_passe',$relations))
		{
			$participe_passe = $motdep -> getAllParticiple();
			$this -> parcourir($motdep,$participe_passe,'participe_passe',$relations);
		}
	}

	/**
	 * Pour une relation lexicale donnée, on inscrit dans le graphe les mots en relation avec le mot de départ
	 *
	 * @param string $motdep : mot de départ
	 * @param array $resultat : liste des mots en relation avec le mot de départ pour la relation sélectionnée
	 * @param string $nomrelation : nom de la relation sélectionnée
	 * @param array $relations : liste des relations lexicales à prendre en compte
	*/
	private function parcourir($motdep,$resultat,$nomrelation,$relations)
	{
		foreach($resultat as $mot)
		{
			//Id du mot exploré
			$id = 'M'.$mot -> getId();

			//Dans l'arbre la relation peut aller dans 2 sens motdep -> motactuel ou motactuel -> motdep
			//Si motactuel -> motdep existe déjà rien à faire (ça signifie qu'on a déjà passé la relation et qu'on est en train de revenir en arrière)
			//Sinon on ajoute motdep -> motactuel
			if (!isset($this -> resultat['graphe'][$id][$nomrelation]))
			{
				$this -> resultat['graphe']['M'.$motdep -> getId()][$nomrelation][] = $id;
			}
			//Si c'est la première fois qu'on rencontre ce noeud, on doit l'inscrire dans la liste des noeuds.
			if (!in_array($id,$this -> listeid))
			{
				$this -> resultat['noeuds'][] = array(
					'id' => $id,
					'nom' => $mot -> getMot(),
					'type' => 'M'
				);
				$this -> resultat['graphe'][$id]['noeud'] = $id;
				$this -> listeid[] = $id;
				$this -> relationsentremots($mot,$relations);
			}
		}
	}

/****************************
  RELATIONS ENTRE SYNSETS : SYNONYMIE
****************************/

	/**
	 * On ajoute un synset, lié au mot qui lui appartient
	 *
	 * @param Mot $mot : le mot donné
	 * @param Synset $syn : le synset donné
	 * @param string $relation : nom de la relation sélectionnée (ex : si le synset a été trouvé en cherchant la relation d'hypernymie, on mettra hypernymie au lieu de synonymie afin que les branches aillent bien d'un mot à un autre, ce qui rendra la visualisation plus lisible à l'utilisateur)
	*/
	private function ajouterSynsets($mot,$syn,$relation = 'synonymie')
	{
		$type = $syn -> getType();
		$id = $type.$syn -> getId();
		//On ajoute le synset dans la liste des noeuds s'il n'y est pas déjà
		if (!in_array($id,$this -> listeid))
		{
			$this -> resultat['noeuds'][] = array(
				'id' => $id,
				'nom' => $syn -> getDefinition(),
				'type' => $type
			);
			$this -> resultat['graphe'][$id]['noeud'] = $id;
			$this -> listeid[] = $id;
		}
		//On inscrit la relation : le mot appartient au synset.
		$this -> resultat['graphe']['M'.$mot -> getId()][$relation][] = $id;
	}

	/**
	 * Pour un synset donné, on cherche les synsets en relation avec lui et les mots qui lui appartiennent
	 *
	 * @param Synset $synset : Le synset donné
	 * @param array $relations : Les relations sélectionnées par l'utilisateur
	 * @param string $relation : nom de la relation sélectionnée (ex : si le synset a été trouvé en cherchant la relation d'hypernymie, on mettra hypernymie au lieu de synonymie afin que les branches aillent bien d'un mot à un autre, ce qui rendra la visualisation plus lisible à l'utilisateur)
	*/
	private function parcourirSynset($synset,$relations,$relation = 'synonymie')
	{
		$type = $synset -> getType();

		//On cherche tous les mots du synset
		$mots = $synset -> getMots();
		//Pour chaque mot on inscrit que le synset contient ce mot et on l'ajoute si il n'y est pas déjà dans la liste de noeuds.
		foreach($mots as $mot)
		{
			$id = 'M'.$mot -> getId();
			if (!isset($this -> resultat['graphe'][$id][$relation]))
			{
				$this -> resultat['graphe'][$type.$synset -> getId()][$relation][] = $id;
			}
			if (!in_array($id,$this -> listeid))
			{
				$this -> resultat['noeuds'][] = array(
					'id' => $id,
					'nom' => $mot -> getMot(),
					'type' => 'M'
				);
				$this -> resultat['graphe'][$id]['noeud'] = $id;
				$this -> listeid[] = $id;
				//Dans le cas où on est en train d'explorer la relation de synonymie et qu'on a pas atteint la profondeur maximale, on va continuer à explorer ce mot.
				//Dans le cas contraire, on a seulement cherché des mots dans le but d'illustrer le synset, donc on continuera l'exploration autour du synset mais pas autour du mot.
				if ($relation == 'synonymie' and $this -> profondeur['synonymie'] < $this -> profondeurMax)
				{
					$this -> profondeur['synonymie']++;
					$this -> parcourirMot($mot,$relations,$relation);
				}
			}
		}
	}

	/**
	 * Pour un mot donné, on cherche ses synsets et leurs relations
	 *
	 * @param Mot $mot : Le mot donné
	 * @param array $relations : Les relations sélectionnées par l'utilisateur
	 * @param string $relation : nom de la relation actuellement en train d'être explorée (utile comme on l'a vu pour la relation d'appartenance à un synset)
	*/
	private function parcourirMot($mot,$relations,$relation)
	{
		//On cherche tous les synsets du mot et pour chacun on ajoute la relation 'ce mot appartient à ce synset'
		$synsets = $mot -> getAllSynsets();
		foreach($synsets as $syn) { $this -> ajouterSynsets($mot,$syn,$relation); }

		//On parcourt la relation de synonymie
		foreach($synsets as $syn) { $this -> parcourirSynset($syn,$relations,$relation); }

		//On cherche les synsets en différenciant leurs type afin de savoir quelles relations peuvent les concerner :
		$nsynsets = $mot -> getNSynsets();
		$asynsets = $mot -> getASynsets();
		$vsynsets = $mot -> getVSynsets();
		$rsynsets = $mot -> getRSynsets();

		//Relations des nsynsets
		foreach($nsynsets as $syn)
		{
			if (in_array('hypernymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'hypernymie','Hypernyms'); }
			if (in_array('hyponymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'hyponymie','Hyponyms'); }
			if (in_array('meronymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'meronymie','Meronyms'); }
			if (in_array('holonymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'holonymie','Holonyms'); }
			if (in_array('attribut',$relations)) { $this -> parcourirRelSynset($syn,$relations,'attribut','HasAttribute'); }
			if (in_array('antonymie',$relations))  { $this -> parcourirRelSynset($syn,$relations,'antonymie','Antonyms'); }
		}

		//Relations des asynsets
		foreach($asynsets as $syn)
		{
			if (in_array('attribut',$relations)) { $this -> parcourirRelSynset($syn,$relations,'attribut','IsAttributeOf'); }
			if (in_array('antonymie',$relations))  { $this -> parcourirRelSynset($syn,$relations,'antonymie','Antonyms'); }
			if (in_array('similar',$relations))  { $this -> parcourirRelSynset($syn,$relations,'similar','Similars'); }
		}

		//Relations des vsynsets
		foreach($vsynsets as $syn) 
		{
			if (in_array('troponymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'troponymie','Troponyms'); }
			if (in_array('verbe_hyponymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'verbe_hyponymie','Hyponyms'); }
			if (in_array('entailments',$relations)) { $this -> parcourirRelSynset($syn,$relations,'entailments','Entails'); }
			if (in_array('verbe_holonymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'verbe_holonymie','Holonyms'); }
			if (in_array('cause',$relations)) { $this -> parcourirRelSynset($syn,$relations,'cause','Causes'); }
			if (in_array('consequence',$relations)) { $this -> parcourirRelSynset($syn,$relations,'consequence','Consequences'); }
			if (in_array('antonymie',$relations))  { $this -> parcourirRelSynset($syn,$relations,'antonymie','Antonyms'); }
		}

		//Relations des rsynsets
		foreach($rsynsets as $syn) 
		{
			if (in_array('antonymie',$relations))  { $this -> parcourirRelSynset($syn,$relations,'antonymie','Antonyms'); }
		}
	}

/****************************
  RELATIONS ENTRE SYNSETS : GENERAL
****************************/
	/**
	 * Pour un synset et une relation donnés, on cherche les synsets en relation avec lui pour la relation donnée
	 *
	 * @param Synset $synsrc : Le synset donné
	 * @param array $relations : Les relations sélectionnées par l'utilisateur
	 * @param string $relation : nom de la relation actuellement en train d'être explorée
	 * @param string $getter : Le nom de la fonction getter correspondant à la relation actuellement explorée (ex : pour la relation Hypernym, le getter est getHypernyms)
	*/
	private function parcourirRelSynset($synsrc,$relations,$relation,$getter)
	{
		//Recherche du getter suivant.
		//Exemple : Si on cherche par exemple un hypernyme, ensuite on cherchera encore un hypernyme de cet hypernyme. C'est comme ça pour toutes les relations sauf pour la relation d'attribut qui se joue entre un nsynset et un asynset. Nom1 a pour attribut Adj1, qui est attribut de Nom2, qui a pour attribut Adj2 etc. (on voit que le nom de la relation alterne à chaque étape)
		if ($getter == 'HasAttribute') { $getternext = 'IsAttributeOf'; }
		else if ($getter == 'IsAttributeOf') { $getternext = 'HasAttribute'; }
		else { $getternext = $getter; }

		//On utilise le getter pour trouver tous les synsets en relation avec le synset donné au départ
		$fonc = 'get' . $getter;
		$rels = $synsrc -> $fonc() -> toArray();

		//Pour chaque synset trouvé : 
		foreach($rels as $syndest)
		{
			//On inscrit si nécessaire la relation entre le synset source et ce synset (ce n'est pas nécessaire si ils sont déjà en relation).
			//Par exemple, si l'utilisateur a demandé hypernymie et hyponymie, on peut trouver que NS1 est hypernyme de NS2 après avoir déjà trouvé que NS2 est hyponyme de NS1.
			$id = $syndest -> getType().$syndest -> getId();
			if (!isset($this -> resultat['graphe'][$id][$relation]))
			{
				$this -> resultat['graphe'][$synsrc -> getType().$synsrc -> getId()][$relation][] = $id;
			}
			//On inscrit aussi ces mots dans le graphe (un synset n'apparait jamais sans ses mots)
			$this -> parcourirSynset($syndest,$relations,$relation);

			//Dans le cas où ce synset n'a pas encore été exploré, on l'enregistre dans le liste des noeuds et on lance l'exploration de ce synset (en utilisant le getternext défini au début de la fonction)
			if (!in_array($id,$this -> listeid))
			{
				$this -> resultat['noeuds'][] = array(
					'id' => $id,
					'nom' => $syndest -> getDefinition(),
					'type' => $syndest -> getType()
				);
				$this -> resultat['graphe'][$id]['noeud'] = $id;
				$this -> listeid[] = $id;
				if ($this -> profondeur[$relation] < $this -> profondeurMax and (in_array($relation,$relations)))
				{
					$this -> profondeur[$relation]++;
					$this -> parcourirRelSynset($syndest,$relations,$relation,$getternext);
				}
			}
		}
	}


}


{% extends "CartoDocumentationBundle:Layouts:layoutWN.html.twig" %}
{% block contenu %}
<h1>{{ "Documentation" | trans }}</h1>
<h2>WordNet</h2>

<h3>{{ "Relations entre les mots" | trans }}</h3>
<ul>
	<li>{{ "Un adjectif ou un verbe dérive d'un nom" | trans }} (ManyToOne).</li>
	<li>{{ "Un adjectif est le participe passé d'un verbe" | trans }} (OneToOne)</li>
	<li>{{ "Un adjectif est le pertainym d'un nom" | trans }} (OneToMany)</li>
	<li>{{ "Un adverbe est construit à partir d'un adjectif" | trans }} (OneToOne)</li>
</ul>
<p>
Remarque : 
{% trans %}
Contrairement aux synsets, les mots ne sont pas typés puisqu'un mot peut appartenir à plusieurs synsets de types différents. Autrement dit, un mot peut être à la fois un adjectif, un verbe et un nom (par exemple work est à la fois un verbe et un nom).
{% endtrans %}
</p>

<img src="{{ asset('bundles/CartoDocumentationBundle/images/DC2.png') }}" width="48%"/>
<img src="{{ asset('bundles/CartoDocumentationBundle/images/DO2.png') }}" width="48%"/>

<h3>{{ "Les fichiers de la base de données WordNet" | trans }}</h3>

<p>
{% trans %}
Nous n'utiliserons pas tous les fichiers offerts par WordNet. Nous utiliserons les fichiers nommés index.noun, index.verb, index.adj, index.adv, data.noun, data.verb, data.adj et data.adv .
{% endtrans %}
</p>
<p>
{% trans %}
Les fichiers index.suffixe recensent tous les mots de WordNet avec les synsets auxquels ils appartiennent. Leurs lignes sont construites de la façon suivante
{% endtrans %} :
<pre>{{ "mot" | trans }} infos [{{ "synsets de type indiqué par le suffixe" | trans }}] </pre>
</p>
<p>
{% trans %}
Ainsi pour connaitre tous les synsets contenant le mot work, nous allons lire dans chaque fichier de type index.suffixe
{% endtrans %} :<br/>
index.noun
<pre>
work n 7 5 @ ~ %p + ; 7 6 00576778 04606723 00585404 05763880 11473837 04609402 03846937  
</pre>
index.verb
<pre>
work v 27 8 ! @ ~ * > $ + ; 27 13 02418610 02415985 02531113 01528454 01672498 00100305 02054955 02600976 02378106 01856435 01632781 02413117 01745327 02757146 02542223 02449024 02441810 02121463 01821541 01663142 01544013 01237919 01165070 00636568 00459709 00459426 00149916  
</pre>
index.adj {{ "et" | trans }} index.adv : {{ "le mot work n'apparait pas dans ces fichiers" | trans }}.<br/>
Conclusion : {{ "Le mot work appartient à 7 synsets de type nom et 27 synsets de type verbe" | trans }}
</p>
<p>
{% trans %}
Il nous reste à lire la partie infos de ces lignes. La lettre n, v, a ou r sert à indiquer le type (nom, verbe, adjectif ou adverbe). Les numéros à moins de 8 chiffres servent à compter les synsets et identifier le mots dans les fichiers lexicographer de WordNet, auxquels nous ne nous intéresserons pas dans ce projet, et enfin les symboles servent à annoncer les relations des synsets référencés. Puisque les relations sont également référencées dans les fichiers data.suffixe, nous éliminerons ces symboles des fichiers index.suffixe . Finalement, nous ne garderons donc que la lettre n, v, a ou r.
{% endtrans %}
</p>
<p>
{{ "Les relations entre les mots sont codées dans les fichiers data.noun, data.verb, data.adj, data.adv de la façon suivante" | trans }}<br/>
index.verb
<pre>00001740 29 v 04 breathe 0 take_a_breath 0 respire 0 suspire ... + 04257960 n 0105</pre>
index.noun
<pre>04257960 06 n 05 snorkel 0 schnorkel 0 schnorchel 0 snorkel_breather 0 breather 0 003 ...</pre>
00001740 + 04257960 n 0105 {{ "se lit" | trans }} : {{ "le premier mot du VSynset 00001740 (ie breathe) est une dérivation du cinquième mot du NSynset 04257960 (ie breather)"}}
</p>

<h3>{{ "Nos fichiers textes adaptés" | trans }}</h3>
<p>
{% trans %}
Deux remarques concernant les fichiers de WordNet et la manière dont nous allons les utiliser
{% endtrans %} :
<ul>
	<li>{{ "Un même mot peut apparaitre plusieurs fois (work apparait à la fois dans index.noun et index.verb)" | trans}}</li>
	<li>{{ "Les relations entre mots sont définis dans les fichiers concernant les synsets, elles sont donc définies plusieurs fois (dans chaque synset contenant les mots concernés par la relation) et la recherche d'un mot en relation avec un autre nous oblige à chercher plusieurs lignes dans des fichiers data différents." | trans }}</li>
</ul>
{{ "Nous allons donc adapter les fichiers de la façon suivante" | trans }} :
<ul>
	<li>{{ "Un seul fichier index.words rédigé ainsi" | trans }} :
		<pre>mot a [ASynsets] n [NSynsets] r [RSynsets] v [VSynsets]</pre>
		Exemples :
		<pre></pre>
	</li>
</ul>
</p>
<p>
	{{ "script de simplification et mélange de tous les fichiers index.suffixe" | trans }}
	<pre>//Renvoie un tableau contenant toutes les lignes simplifiées d'un fichier index.suffix donné
public function simplifyindex($suffixe,$lettre)
{
  $index = fopen('../src/Carto/DocumentationBundle/Resources/dict/index.'. $suffixe,'r');
  $reponse = array();

  //On lit chaque ligne du fichier
  while ($ligne = fgets($index))
  {
    //On découpe la ligne
    $tab = explode(' ',$ligne);
    $nouvligne = '';
    //On ne garde que le mot, la lettre indiquant le type et les numéros de synsets
    foreach($tab as $cle => $elem)
    {
      if ($elem == $lettre or $cle == 0 or strlen($elem) > 2) { $nouvligne .= $elem . ' '; }
    }
    $reponse[] = $nouvligne;
  }

  fclose($index);
  return $reponse;
}

//Met ensemble les 4 fichiers d'index simplifiés
public function mixindexAction()
{
  //On met bout à bout les lignes de tous les fichiers index.suffixe
  $lignes = array();
  $lignes = array_merge($lignes,$this -> simplifyindex('adj','a'));
  $lignes = array_merge($lignes,$this -> simplifyindex('noun','n'));
  $lignes = array_merge($lignes,$this -> simplifyindex('adv','r'));
  $lignes = array_merge($lignes,$this -> simplifyindex('verb','v'));

  //On trie le tableau obtenu par ordre alphabétique
  sort($lignes);

  //On dresse la liste de tous les mots référencés
  $mot = array();
  foreach($lignes as $cle => $l)
  {
    $tab = explode(' ',$l,2);
    $mot[] = $tab[0];
  }

  //On parcourt les lignes, en mettant ensemble les lignes référençant un même mot
  $reponse = '';
  foreach($lignes as $cle => $l)
  {
    //On coupe la ligne en deux : le mot puis la suite contenant la lettre et les synsets
    $tab = explode(' ',$l,2);
    //Si le mot est le même qu'à la ligne précédente, on se contente d'ajouter la suite au bout
    if ($cle != 0 and $mot[$cle - 1] == $mot[$cle]) { $reponse .= $tab[1] . '&nbsp;'; }
    //Sinon on met toute la ligne en dessous de la précédente
    else { $reponse .= $l . '&nbsp;'; }
    //On doit prévoir de sauter une ligne ou non selon que la prochaine ligne référence un nouveau mot ou le même mot
    if (isset($mot[$cle + 1]) and $mot[$cle + 1] != $mot[$cle]) { $reponse .= '<br/>' ; }
  }

  //On renvoie le fichier simplifié et mixé
  return new Response($reponse);
}</pre>
</p>
<a href="{{ path('carto_documentation_etudewn_simplifierindex') }}" target="blank">{{ "Voir le résultat du script (peut prendre quelques minutes)" | trans }}</a>
<p> {{ "Il nous faut maintenant ajouter les relations" | trans }}</p>
<a href="{{ path('carto_documentation_etudewn_ajouterderivation') }}" target="blank">{{ "Voir le résultat du script (peut prendre quelques minutes)" | trans }}</a>
{% endblock %}

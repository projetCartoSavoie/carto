<?php
/**
 * MotRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 *
 * @author Rémy Cluze <Remy.Cluze@etu.univ-savoie.fr>
 * @author Anthony Di Lisio <Anthony.Di-Lisio@etu.univ-savoie.fr>
 * @author Juliana Leclaire <Juliana.Leclaire@etu.univ-savoie.fr>
 * @author Rémi Mollard <Remi.Mollard@etu.univ-savoie.fr>
 * @author Céline de Roland <Celine.de-Roland@etu.univ-savoie.fr>
 *
 * @version 1.0
 */
namespace Carto\DonneesBundle\Entity\WN;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Query\Expr\Comparison;

/**
 * MotRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class MotRepository extends EntityRepository
{

/**
 * Résultat
 *
 * @var array $resultat : tableau php représentant le graphe autour d'un mot
 */
	private $resultat;

/**
 * Mot
 *
 * @var Carto\DonneesBundle\Entity\WN\Mot : mot demandé
 */
	private $mot;

	private $profondeur;

	private $numero = 0;

	private $profondeurMax = 5;

	/**
	 * fonction trouve
	 *
	 * Si le mot cherché est dans la base de données, alors la fonction
	 * renvoie le mot correspondant
	 * Sinon on cherche un mot qui ressemble à la recherche dans la bdd
	 * et on renvoie le mot correspondant
	 *
	 * @param string $recherche
	 * @return Carto\DonneesBundle\Entity\WN\Mot
	*/
	public function trouve($recherche)
	{
		$mot = $this -> findOneByMot($recherche);
		if ($mot != NULL)
		{
			return $mot;
		}
		else
		{
			//On cherche tous les mots ayant 3 caractères en commun avec la recherche
			$query = $this->getEntityManager()->createQuery(
				'SELECT m
				FROM CartoDonneesBundle:WN\Mot m
				WHERE m.mot LIKE :court'
			);
			$mots = array();
			for ($i = 0; $i < strlen($recherche) - 2; $i++)
			{
				$regex = substr($recherche,$i,3);
				$query->setParameter('court', '%'.$regex.'%');
				$mots = array_merge($mots, $query -> getResult());
			}

			//On remplace le tableau d'objets par un tableau de chaines de caractères
			$strmots = array();
			foreach ($mots as $m)
			{
				$strmots[] = $m -> getMot();
			}

			//Pour chaque mot on calcule son taux de correspondance
			$correspondances = array();
			foreach ($strmots as $m)
			{
				$correspondance[$m] = $this -> calculCorrespondance($m,$recherche);
			}
			$minindex = min($correspondance);
			$correspondance = array_flip($correspondance);

			//On retourne l'objet Mot correspondant au plus bas taux de correspondance
			$mot = $this -> findOneByMot($correspondance[$minindex]);
			return $mot;
		}
	}

	/**
	 * Calcul un taux de différence entre deux mots
	 *
	 * tient compte de la ressemblance sonore et de la
	 * ressemblance en terme de caractères (nombre d'insertions et suppressions
	 * nécessaires pour passer d'une chaine à l'autre)
	 * plus le résultat est petit plus les mots se ressemblent
	 *
	 * @param string $recherche
	 * @param string $m (mot à comparer à la recherche)
	 * @return integer
	*/
	public function calculCorrespondance($m,$recherche)
	{
		$c = levenshtein($m,$recherche);
		if (soundex($m) == soundex($recherche)) { $c -= 10; }
		return $c;
	}

	public function fabriqueGraphe($recherche,$options)
	{

		$this -> profondeur = array(
				'hypernymie' => 0,
				'hyponymie' => 0,
				'meronymie' => 0,
				'holonymie' => 0,
				'troponymie' => 0,
				'verbe_hyponymie' => 0,
				'entailments' => 0,
				'verbe_holonymie' => 0,
				'antonymie' => 0,
				'attribut' => 0,
				'cause' => 0,
				'consequence' => 0,
				'similar' => 0,
				'synonymie' => 0
		);
		if ($options == 'all')
		{
			$relations = array(
				'derivation',
				'pertainymie',
				'construction',
				'participe_passe',
				'hypernymie',
				'hyponymie',
				'meronymie',
				'holonymie',
				'troponymie',
				'verbe_hyponymie',
				'entailments',
				'antonymie',
				'attribut',
				'cause',
				'consequence',
				'similar',
				'synonymie',
			);
		}
		else { $relations = explode(',',$options); }
		
		//Initialisation du tableau résultat, qui sera ensuite encodé en json
		$this -> resultat = array(
			'noeuds' => array(), 
			'relations' => array_merge($relations,array('groupe_initial')),
			'graphe' => array()
		);

		//Recherche du mot demandé et ajout dans la liste des noeuds et dans le graphe
		$this -> mot = $this -> trouve($recherche);
		$this -> resultat['noeuds'][] = array(
			'id' => 'M'.$this -> mot -> getId(),
			'nom' => $this -> mot -> getMot(),
			'type' => 'M'
		);
		$this -> resultat['graphe']['M'.$this -> mot -> getId()] = array( 'noeud' => 'M'.$this -> mot -> getId() );
		$this -> listeid = array('M'.$this -> mot -> getId());

		//On cherche les relations entre mots
		$relations_mots = array(
				'derivation',
				'pertainymie',
				'construction',
				'participe_passe'
		);
		$this -> relationsentremots($this -> mot,array_intersect($relations_mots,$relations));


		//Si on veut d'autres relations, on cherche les synsets du mot et leurs relations
		$relationsentresynsets = array_diff($relations,$relations_mots);
		if (count($relationsentresynsets) != 0)
		{
			if (in_array('synonymie',$relations)) { $this -> parcourirMot($this -> mot,$relations,'synonymie'); }
			else { $this -> parcourirMot($this -> mot,$relations,'groupe_initial'); }
		}
		//On enlève les clés du tableau graphe pour correspondre au format commun
		$this -> resultat['graphe'] = array_values($this -> resultat['graphe']);

		//On retourne le tableau obtenu
		return $this -> resultat;

	}

/****************************
  RELATIONS ENTRE MOTS
****************************/
	private function relationsentremots($motdep,$relations)
	{
		if (in_array('derivation',$relations))
		{
			$derivation = $motdep -> getAllDerive();
			$this -> parcourir($motdep,$derivation,'derivation',$relations);
		}
		if (in_array('pertainymie',$relations))
		{
			$pertainymie = $motdep -> getAllPertainym();
			$this -> parcourir($motdep,$pertainymie,'pertainymie',$relations);
		}
		if (in_array('construction',$relations))
		{
			$construction = $motdep -> getAllBuild();
			$this -> parcourir($motdep,$construction,'construction',$relations);
		}
		if (in_array('participe_passe',$relations))
		{
			$participe_passe = $motdep -> getAllParticiple();
			$this -> parcourir($motdep,$participe_passe,'participe_passe',$relations);
		}
	}

	private function parcourir($motdep,$resultat,$nomrelation,$relations)
	{
		foreach($resultat as $mot)
		{
			$id = 'M'.$mot -> getId();
			if (!isset($this -> resultat['graphe'][$id][$nomrelation]))
			{
				$this -> resultat['graphe']['M'.$motdep -> getId()][$nomrelation][] = $id;
			}
			if (!in_array($id,$this -> listeid))
			{
				$this -> resultat['noeuds'][] = array(
					'id' => $id,
					'nom' => $mot -> getMot(),
					'type' => 'M'
				);
				$this -> resultat['graphe'][$id]['noeud'] = $id;
				$this -> listeid[] = $id;
				$this -> relationsentremots($mot,$relations);
			}
		}
	}

/****************************
  RELATIONS ENTRE SYNSETS : SYNONYMIE
****************************/

	private function ajouterSynsets($mot,$syn,$relation='synonymie')
	{
		$type = $syn -> getType();
		$id = $type.$syn -> getId();
		if (!in_array($id,$this -> listeid))
		{
			$this -> resultat['noeuds'][] = array(
				'id' => $id,
				'nom' => $syn -> getDefinition(),
				'type' => $type
			);
			$this -> resultat['graphe'][$id]['noeud'] = $id;
			$this -> listeid[] = $id;
		}
		$this -> resultat['graphe']['M'.$mot -> getId()][$relation][] = $id;
	}

	private function parcourirSynset($synset,$relations,$relation='synonymie')
	{
		$mots = $synset -> getMots();
		$type = $synset -> getType();
		foreach($mots as $mot)
		{
			$id = 'M'.$mot -> getId();
			if (!isset($this -> resultat['graphe'][$id][$relation]))
			{
				$this -> resultat['graphe'][$type.$synset -> getId()][$relation][] = $id;
			}
			if (!in_array($id,$this -> listeid))
			{
				$this -> resultat['noeuds'][] = array(
					'id' => $id,
					'nom' => $mot -> getMot(),
					'type' => 'M'
				);
				$this -> resultat['graphe'][$id]['noeud'] = $id;
				$this -> listeid[] = $id;
				if ($relation == 'synonymie' and $this -> profondeur['synonymie'] < $this -> profondeurMax)
				{
					$this -> profondeur['synonymie']++;
					$this -> parcourirMot($mot,$relations,$relation);
				}
				/*else if ($relation != 'synonymie')
				{
					$this -> parcourirMot($mot,$relations,$relation);
				}*/
			}
		}
	}

	private function parcourirMot($mot,$relations,$relation)
	{
		$synsets = array_merge($mot -> getASynsets() -> toArray(),$mot -> getNSynsets() -> toArray(),$mot -> getVSynsets() -> toArray(),$mot -> getRSynsets() -> toArray());
		foreach($synsets as $syn) { $this -> ajouterSynsets($mot,$syn,$relation); }

		//On parcourt la relation de synonymie
		//if (in_array('synonymie',$relations) and $this -> profondeur['synonymie'] < $this -> profondeurMax)
		//{
			foreach($synsets as $syn) { $this -> parcourirSynset($syn,$relations,$relation); }
		//}

		//Relations des nsynsets :
		$nsynsets = $mot -> getNSynsets();
		$asynsets = $mot -> getASynsets();
		$vsynsets = $mot -> getVSynsets();
		$rsynsets = $mot -> getRSynsets();

		foreach($nsynsets as $syn)
		{
			if (in_array('hypernymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'hypernymie','Hypernyms'); }
			if (in_array('hyponymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'hyponymie','Hyponyms'); }
			if (in_array('meronymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'meronymie','Meronyms'); }
			if (in_array('holonymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'holonymie','Holonyms'); }
			if (in_array('attribut',$relations)) { $this -> parcourirRelSynset($syn,$relations,'attribut','HasAttribute'); }
			if (in_array('antonymie',$relations))  { $this -> parcourirRelSynset($syn,$relations,'antonymie','Antonyms'); }
		}

		foreach($asynsets as $syn)
		{
			if (in_array('attribut',$relations)) { $this -> parcourirRelSynset($syn,$relations,'attribut','IsAttributeOf'); }
			if (in_array('antonymie',$relations))  { $this -> parcourirRelSynset($syn,$relations,'antonymie','Antonyms'); }
			if (in_array('similar',$relations))  { $this -> parcourirRelSynset($syn,$relations,'similar','Similars'); }
		}

		foreach($vsynsets as $syn) 
		{
			if (in_array('troponymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'troponymie','Troponyms'); }
			if (in_array('verbe_hyponymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'verbe_hyponymie','Hyponyms'); }
			if (in_array('entailments',$relations)) { $this -> parcourirRelSynset($syn,$relations,'entailments','Entails'); }
			if (in_array('verbe_holonymie',$relations)) { $this -> parcourirRelSynset($syn,$relations,'verbe_holonymie','Holonyms'); }
			if (in_array('cause',$relations)) { $this -> parcourirRelSynset($syn,$relations,'cause','Causes'); }
			if (in_array('consequence',$relations)) { $this -> parcourirRelSynset($syn,$relations,'consequence','Consequences'); }
			if (in_array('antonymie',$relations))  { $this -> parcourirRelSynset($syn,$relations,'antonymie','Antonyms'); }
		}

		foreach($rsynsets as $syn) 
		{
			if (in_array('antonymie',$relations))  { $this -> parcourirRelSynset($syn,$relations,'antonymie','Antonyms'); }
		}
	}

/****************************
  RELATIONS ENTRE SYNSETS : GENERAL
****************************/
	private function parcourirRelSynset($synsrc,$relations,$relation,$getter)
	{
		if ($getter == 'HasAttribute') { $getterinv = 'IsAttributeOf'; }
		else if ($getter == 'IsAttributeOf') { $getterinv = 'HasAttribute'; }
		else { $getterinv = $getter; }
		$fonc = 'get' . $getter;
		$rels = $synsrc -> $fonc() -> toArray();
		foreach($rels as $syndest)
		{
			$id = $syndest -> getType().$syndest -> getId();
			if (!isset($this -> resultat['graphe'][$id][$relation]))
			{
				$this -> resultat['graphe'][$synsrc -> getType().$synsrc -> getId()][$relation][] = $id;
			}
			$this -> parcourirSynset($syndest,$relations,$relation);

			if (!in_array($id,$this -> listeid))
			{
				$this -> resultat['noeuds'][] = array(
					'id' => $id,
					'nom' => $syndest -> getDefinition(),
					'type' => $syndest -> getType()
				);
				$this -> resultat['graphe'][$id]['noeud'] = $id;
				$this -> listeid[] = $id;
				if ($this -> profondeur[$relation] < $this -> profondeurMax and (in_array($relation,$relations)))
				{
					$this -> profondeur[$relation]++;
					$this -> parcourirRelSynset($syndest,$relations,$relation,$getterinv);
				}
			}
		}
	}


}
